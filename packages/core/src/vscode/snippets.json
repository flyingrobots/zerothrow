{
  "ZeroThrow: Import essentials": {
    "prefix": "ztimport",
    "body": [
      "import { ZT, ZeroThrow, Result } from '@zerothrow/zerothrow';",
      "const { ok, err } = ZeroThrow;"
    ],
    "description": "Import ZeroThrow essentials"
  },
  
  "ZeroThrow: Ok Result": {
    "prefix": "ztok",
    "body": [
      "return ok(${1:value});"
    ],
    "description": "Return an Ok result"
  },
  
  "ZeroThrow: Err Result": {
    "prefix": "zterr", 
    "body": [
      "return err(${1:error});"
    ],
    "description": "Return an Err result"
  },
  
  "ZeroThrow: Wrap Error": {
    "prefix": "ztwrap",
    "body": [
      "return err(ZeroThrow.wrap(${1:error}, '${2:ERROR_CODE}', '${3:Error message}'));"
    ],
    "description": "Wrap an error with code and message"
  },
  
  "ZeroThrow: Error Creation": {
    "prefix": "zterror",
    "body": [
      "new ZeroThrow.ZeroError('${1:ERROR_CODE}', '${2:Error message}'${3:, { context: \\{ ${4} \\} \\}})"
    ],
    "description": "Create a new ZeroError instance"
  },
  
  "ZeroThrow: Result Type": {
    "prefix": "ztresult",
    "body": [
      "Result<${1:T}, ${2:ZeroThrow.ZeroError}>"
    ],
    "description": "ZeroThrow Result type annotation"
  },
  
  "ZeroThrow: Async Function with ZT.try": {
    "prefix": "ztasync",
    "body": [
      "async function ${1:functionName}(${2:params}): Promise<Result<${3:ReturnType}, ZeroThrow.ZeroError>> {",
      "  return ZT.try(async () => {",
      "    ${4:// implementation}",
      "    return ${5:result};",
      "  }, e => ZeroThrow.wrap(e, '${6:ERROR_CODE}', '${7:Error message}'));",
      "}"
    ],
    "description": "Async function using ZT.try"
  },
  
  "ZeroThrow: Handle Result": {
    "prefix": "zthandle",
    "body": [
      "const result = await ${1:asyncFunction}();",
      "if (!result.ok) {",
      "  ${2:// handle error: result.error}",
      "  return result;",
      "}",
      "const ${3:value} = result.value;"
    ],
    "description": "Handle a Result type"
  },
  
  "ZeroThrow: Transform Result with combinators": {
    "prefix": "ztcombine",
    "body": [
      "import { makeCombinable } from '@zerothrow/zerothrow';",
      "",
      "const result = makeCombinable(${1:initialResult})",
      "  .map(${2:value} => ${3:transformation})",
      "  .mapErr(${4:error} => ${5:errorTransformation})",
      "  .unwrapOr(${6:defaultValue});"
    ],
    "description": "Use combinators to transform Result"
  },
  
  "ZeroThrow: Map Result": {
    "prefix": "ztmap",
    "body": [
      "import { makeCombinable } from '@zerothrow/zerothrow';",
      "",
      "makeCombinable(${1:result}).map(${2:value} => ${3:transformation})"
    ],
    "description": "Map over a successful Result using combinators"
  },
  
  "ZeroThrow: Chain Results": {
    "prefix": "ztchain",
    "body": [
      "import { makeCombinable } from '@zerothrow/zerothrow';",
      "",
      "makeCombinable(${1:result})",
      "  .andThen(${2:value} => ${3:nextOperation})",
      "  .mapErr(${4:error} => ${5:errorTransformation})"
    ],
    "description": "Chain Result operations using combinators"
  },
  
  "ZeroThrow: ZT.try wrapper": {
    "prefix": "zttry",
    "body": [
      "const result = await ZT.try(() => {",
      "  ${1:// code that might throw}",
      "});"
    ],
    "description": "Wrap potentially throwing code with ZT.try"
  },
  
  "ZeroThrow: Synchronous Function with Result": {
    "prefix": "ztsync",
    "body": [
      "function ${1:functionName}(${2:params}): Result<${3:ReturnType}, ZeroThrow.ZeroError> {",
      "  try {",
      "    ${4:// implementation}",
      "    return ok(${5:result});",
      "  } catch (e) {",
      "    return err(ZeroThrow.wrap(e, '${6:ERROR_CODE}', '${7:Error message}'));",
      "  }",
      "}"
    ],
    "description": "Synchronous function returning Result"
  }
}